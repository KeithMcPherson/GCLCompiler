Compiled on: Mon May 23 17:08:05 EDT 2011
module test13_1
$        LDA     R15, V1
$        LDA     R14, C1
$        LD      R13, #16000
$        LD      R12, R13
$        LD      R11, R13
private
$        JMP     M1
{ test of array and tuple component extraction }
	 integer a,b,x;
	  tuple [integer first, integer second] pair;
	 typedefinition integer range [1..3] subs;
	 typedefinition integer array [subs] values;
	 values z;
	 tuple [integer size, values val] nested;
	 
	 
 begin
	 read b; { Use 2 as input value. }
$    LABEL M1
$        RDI     +2(R15)
	 x := 1;
$        LD      R0, +4(R14)
$        STO     R0, +4(R15)
	 a := b + x;
$        LD      R0, +2(R15)
$        IA      R0, +4(R15)
$        STO     R0, +0(R15)
	 pair := [x , b + 1];
$        LD      R0, +2(R15)
$        IA      R0, +6(R14)
$        LD      R1, +4(R15)
$        STO     R1, +24(R15)
$        STO     R0, +26(R15)
$        IS      R13, #4
$        LDA     R0, +24(R15)
$        LD      R1, #4
$        BKT     R0, *R13
$        LD      R0, R13
$        LD      R1, #4
$        BKT     R0, +6(R15)
$        IA      R13, #4
	 write pair@first, pair@second - 2; { 11 }
$        WRI     +6(R15)
$        LD      R0, +8(R15)
$        IS      R0, +8(R14)
$        WRI     R0
$        WRNL    
	 if b = 2 ->	a := 1;
$        LD      R1, +2(R15)
$        LD      R0, #1
$        IC      R1, +10(R14)
$        JEQ     &4
$        LD      R0, #0
$        IC      R0, #1
$        JNE     J3
$        LD      R0, +12(R14)
$        STO     R0, +0(R15)
	 		b := 1;
$        LD      R0, +14(R14)
$        STO     R0, +2(R15)
	 [] b = 100 ->	a := 6;
$        JMP     J2
$    LABEL J3
$        LD      R1, +2(R15)
$        LD      R0, #1
$        IC      R1, +16(R14)
$        JEQ     &4
$        LD      R0, #0
$        IC      R0, #1
$        JNE     J4
$        LD      R0, +18(R14)
$        STO     R0, +0(R15)
			b := 100 / a;
$        LD      R0, +20(R14)
$        ID      R0, +0(R15)
$        STO     R0, +2(R15)
	 [] b # 2  -> skip;
$        JMP     J2
$    LABEL J4
$        LD      R1, +2(R15)
$        LD      R0, #1
$        IC      R1, +22(R14)
$        JNE     &4
$        LD      R0, #0
$        IC      R0, #1
$        JNE     J5
	 fi;
$        JMP     J2
$    LABEL J5
$        HALT    
$    LABEL J2
	 write a, b, x, b*x ; {1111}
$        WRI     +0(R15)
$        WRI     +2(R15)
$        WRI     +4(R15)
$        LD      R0, +2(R15)
$        IM      R0, +4(R15)
$        WRI     R0
$        WRNL    
	 pair@second := 1;
$        LD      R0, +24(R14)
$        STO     R0, +8(R15)
	 write pair@first, pair@second; {11}
$        WRI     +6(R15)
$        WRI     +8(R15)
$        WRNL    
	 z[1], z[2], z[3] := 3, 2, 1;
$        LDA     R0, +10(R15)
$        LD      R1, +26(R14)
$        TRNG    R1, +0(R14)
$        IS      R1, #1
$        IM      R1, #2
$        IA      R0, R1
$        LDA     R1, +10(R15)
$        LD      R2, +28(R14)
$        TRNG    R2, +0(R14)
$        IS      R2, #1
$        IM      R2, #2
$        IA      R1, R2
$        LDA     R2, +10(R15)
$        LD      R3, +30(R14)
$        TRNG    R3, +0(R14)
$        IS      R3, #1
$        IM      R3, #2
$        IA      R2, R3
$        LD      R3, +32(R14)
$        STO     R3, *R2
$        LD      R2, +34(R14)
$        STO     R2, *R1
$        LD      R1, +36(R14)
$        STO     R1, *R0
	 nested := [3, z];
$        LD      R0, +38(R14)
$        STO     R0, +28(R15)
$        LDA     R0, +10(R15)
$        LD      R1, #6
$        BKT     R0, +30(R15)
$        IS      R13, #8
$        LDA     R0, +28(R15)
$        LD      R1, #8
$        BKT     R0, *R13
$        LD      R0, R13
$        LD      R1, #8
$        BKT     R0, +16(R15)
$        IA      R13, #8
	 write nested@val[z[1]]; {1}
$        LDA     R0, +10(R15)
$        LD      R1, +40(R14)
$        TRNG    R1, +0(R14)
$        IS      R1, #1
$        IM      R1, #2
$        IA      R0, R1
$        LDA     R1, +18(R15)
$        LD      R2, *R0
$        TRNG    R2, +0(R14)
$        IS      R2, #1
$        IM      R2, #2
$        IA      R1, R2
$        WRI     *R1
$        WRNL    
 end. 
$        HALT    
$    LABEL C1
$        INT      1
$        INT      3
$        INT      1
$        INT      1
$        INT      2
$        INT      2
$        INT      1
$        INT      1
$        INT      100
$        INT      6
$        INT      100
$        INT      2
$        INT      1
$        INT      1
$        INT      2
$        INT      3
$        INT      1
$        INT      2
$        INT      3
$        INT      3
$        INT      1
$    LABEL V1
$        SKIP     36
  <end of compilation of ..\tests\test13_1>.  There were no errors detected.
  Allocated Registers: 0 11 12 13 14 15 

